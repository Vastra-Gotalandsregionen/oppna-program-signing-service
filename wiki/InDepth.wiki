#summary Djupgående genomgång av hur man använder signeringstjänsten.

= Bakgrund och ändamål =

En elektronisk signatur ska säkerställa att elektroniskt överförd information inte har ändrats
och för att identifiera informationens avsändare. Genom kryptering skyddas uppgifter i ett
dokument mot obehörig åtkomst.

== Vad är en elektronisk signatur? ==
En elektroniskt underskriven handling består av två delar. Dels _texten_ som skall signeras och dels själva signaturen. För att säkerställa att en _text_ är identisk vid två olika tillfällen beräknas en kontrollsumma av _texten_. Denna kontrollsumma är _alltid_ densamma så länge _texten_ inte har förändrats och därmed kan man garantera att _texten_ inte har förändrats över tid. Detta är dock inte tillräckligt utan man behöver även kunna säkerställa _vem_ som har utfärdat _texten_. Detta görs genom att kontrollsumman krypteras med undertecknarens privat nyckel. Dekryptering kan sedan _endast_ göras med hjälp av undertecknarens publika nyckel. Nu kan man med säkerhet knyta en viss _text_ till en bestämd utställare.

I den digitala signatur som genereras finns tillräckligt med information för att kontrollera äktheten hos en elektroniskt underskriven handling. Formatet på dessa signaturer kommer i två varianter, [http://tools.ietf.org/html/rfc5652 PKCS#7] eller [http://www.w3.org/TR/xmldsig-core/ XMLDSig] beroende på vilken typ av e-legitimation som används vid signeringstillfället.

== Hur signerar jag utan signeringtjänsten? ==
Första steget för en applikation är att erbjuda signering för en användare. När användaren har bett om signering måste applikationen visa en signeringsklient för användaren som skall utföra själva signeringen. Här måste applikationen ta hänsyn till vad för typ av certifikat som användaren vill signera med samt vilken browser som används. I nästa steg måste applikationen ta emot signaturen och genomföra en kontroll av den för att verifiera att certifikatet som användes vid signeringen är giltligt. Det som verifieras är att certifikatet är utfärdat av en giltig CA-Root, att det inte är revokerat samt att det inte har gått ut. I sista steget måste applikationen spara signaturen för framtida behov. Nedan visas en schematisk bild över hur flödet ser ut, de heldragna pilarna är de interaktioner som måste hanteras/implementeras av applikationen.
http://oppna-program-signing-service.googlecode.com/svn/wiki/images/Signature-process.png

= Funktionsbeskrivning =

== Hur signerar jag med signeringtjänsten? ==
Första steget för en applikation är att erbjuda signering för en användare. Efter detta tar signeringstjänsten över och hanterar presentationen av signeringsklineten (t.ex. NetID) med allt vad det innebär, signeringstjänsten tar även hand om certifikatskontrollen som bla. verifierar att certifikatet som används i signaturen inte är spärrat. Det den nyttjande applikationen behöver ta hänsyn till är lagringen av signaturen. Nedan visas en schematisk bild över hur flödet ser ut, de heldragna pilarna är de interaktioner som måste hanteras/implementeras av applikationen.
http://oppna-program-signing-service.googlecode.com/svn/wiki/images/Signatureservice-process.png

== Vad gör signeringstjänsten för mig? ==
Signeringstjänsten hjälper till med följande:
 * Möjlighet att visa ett gränssnitt för val av signerings-certifikat
 * Presenatation av olika signeringsklienter beroende på certifikat
 * Hantering av olika webbläsare
 * Verifiering av utfärdad signatur

= Översiktlig systembeskrivning =
<img src="http://oppna-program-signing-service.googlecode.com/svn/wiki/images/solution.png" width="800"/>

 # Klienten begär att få något signerat(TBS – To Be Signed) av SS. Rekommenderat är att skicka en kontrollsumma av TBS. Kontrollsumman är förslagsvis beräknad utifrån [http://en.wikipedia.org/wiki/SHA-2 SHA-2](t.ex. SHA-256) för att få en ökad säkerhet. SS behöver även ha en submitUri dit signaturen skall skickas när den är klar. Valbart(optional) är att skicka in en clientType.
 # Har ingen clientType skickats med visas ett val av tillgängliga clientTypes för användaren. SS tar fram ett block av html/xhtml([http://en.wikipedia.org/wiki/Public_key_infrastructure PKI] Client Code) baserat på clientType och TBS som den visar för klienten.
 # [http://en.wikipedia.org/wiki/Public_key_infrastructure PKI]-klienten startar upp för signering hos användaren.
 # Användaren matar in lösenord för sin privata nyckel och TBS signeras. [http://en.wikipedia.org/wiki/Public_key_infrastructure PKI]-klienten postar signaturen [http://en.wikipedia.org/wiki/Cryptographic_Message_Syntax PKSC#7] eller [http://www.w3.org/TR/xmldsig-core/ XML-Signature]) till SS. Vilket format som skickas till SS beror på clientType.
 # Signaturen verifieras via en [http://sveid.episerverhotell.net/SVEIDtemplates/SVEIDpage.aspx?id=124 OSIF] tjänst.
 # Status för hur valideringen gick skickas tillbaka till SS.
 # SS skickar signaturen till submitUri för lagring, detta sker över ftps eller https. Om https väljs finns även en möjlighet för applikationen att själv presentera status för signeringen (se steg 7). I annat fall kommer SS att hantera presentationen av status.
 # Om X själv kan och vill presentera status för signeringen gör den en [http://en.wikipedia.org/wiki/HTTP_302 302 Moved Temporary] till en url som hanterar presentationen. Om X vill överlåta detta till SS räcker det med att svara med en vanlig [http://en.wikipedia.org/wiki/List_of_HTTP_status_codes 200 OK] response.
 # Om SS får en [http://en.wikipedia.org/wiki/HTTP_302 302 Moved Temporary] från X skickar även SS en [http://en.wikipedia.org/wiki/HTTP_302 302 redirect] tillbaka till klienten med samma location som X satte i sin redirect. Om SS får en [http://en.wikipedia.org/wiki/List_of_HTTP_status_codes 200 OK] visar den en status sida för klienten.
 # [http://en.wikipedia.org/wiki/HTTP_302 302 Moved Temporary] till location satt av X.
 # X visar ett svar för klienten.
*Kommentarer*
 &#42;Steg 10 och 11 kommer endast att inträffa om X gör en [http://en.wikipedia.org/wiki/HTTP_302 302 Moved Temporary] i steg 8.

== Säkerhet ==
För att garantera säkerheten bör all kommunikation ske över en krypterad anslutning – https. Det finns dock fortfarande en risk att SS blir utsatt för en attack och [http://en.wikipedia.org/wiki/Man-in-the-middle_attack ersätts av en ”elak”] SS som byter ut signatur och certifikat. För att förhindra detta är det starkt rekommenderat att X sätter upp [http://en.wikipedia.org/wiki/Transport_Layer_Security TLS] mot SS. [http://en.wikipedia.org/wiki/Transport_Layer_Security TLS] syftar till att genom utbyte av certifikat mellan SS och X kan X grantera att identiteten på SS. Alltså, med tillgång till SS publika nyckel kan X verifiera att det är SS som skickar signaturen till submitUri.

== Ordlista ==
|| *Begrepp* || *Förklaring* ||
|| TBS || To Be Signed. Data som skall signeras. ||
|| submitUri  || Uri dit signaturen skall skickas efter signering. ||
|| clientType || Typ av signering, i dagsläget har Signeringstjänsten stöd för !BankId, Nordea, Posten och SITHS. ||

= Sekvensdiagram =
http://oppna-program-signing-service.googlecode.com/svn/wiki/sequencediagrams/system-level.png

= Projektstruktur =
Signeringstjänsten består egentligen av två projekt:
 * *signer-service* som i sin tur består av två moduler:
   * core-bc - detta är själva signeringstjänsten
   * reference-application - en konsument  som fungerar som ett exempel på hur man kan utnyttja signeringstjänsten
 * *signer-service-schemas* - innehåller schemat för det xml-meddelande, innehållandes signaturen, som skickas från signeringstjänsten till konsumenten.

= Installation =
Signeringstjänsten behöver konfigureras en hel  innan den kan startas. Detta beror på att den använder sig av [http://en.wikipedia.org/wiki/Transport_Layer_Security TLS] för att datan som skickas mellan den och konsumenterna. För att i möjligaste mån underlätta så mycket som möjligt för utvecklarna av tjänsten har en viss default-konfiguration paketerats med i projektet. För en produktionsinstans måste dock denna konfiguration anpassas. Hur man gör detta beskrivs i avsnittet [InDepth#Konfiguration konfiguration] längre ner i dokumentationen.

Även konsumenterna av signeringstjänsten kräver en del TLS-konfiguration vilket finns beskrivet i avsnittet [http://code.google.com/p/oppna-program-signing-service/wiki/InDepth#Anslut_till_signeringstjänsten Anslut till signeringstjänsten].

==  Sätta upp en instans av signeringstjänsten ==

=== Utvecklingsmiljö ===
Att sätta upp en utvecklingsmiljö för signeringstjänsten är relativt enkelt:
 # Ladda ner källkoden från https://oppna-program-signing-service.googlecode.com/svn/signer-service/trunk/
 # Kopiera hela katalogen core-bc/modules/web/doc/.ss till din hemkatalog (ex. {{{/Users/<name>/.ss}}}). Mer om vad den innehåller finns beskrivet i avsnittet [InDepth#Konfiguration konfiguration]
 # Navigera dig fram till core-bc/modules/web i ett terminal-/kommandofönster
 # Kör maven-kommandot {{{mvn jetty:run}}}

=== Produktionsmiljö ===

== Konfiguration ==

== Certikathantering ==
Nedan visas en bild över vilka certifikat som används i de olika delarna av signaturprocessen: 
http://oppna-program-signing-service.googlecode.com/svn/wiki/images/Certifikathantering.png

== Anslut till signeringstjänsten ==
In nedanstående guide kommer vi att gå igenom steg för steg hur man ansluter till signeringstjänsten. För att underlätta processen så kommer vi att göra det iterativt, första steget är att få det fungera över vanlig http, nästa steg blir att aktivera SSL/TLS och i sista steget lägger vi på Mutual Authentication.

 # Det första vi behöver sätta upp är en tjänst dit signeringstjänsten kan leverera signaturen. Detta kan vara antingen i form av en http- eller ftp-server, här kommer vi att beskriva fallet http-server. Tjänsten måste acceptera POST med följande parametrar i dess body:
  * `envelope - XML-envelope innehållande  signaturen`
 # Nästa steg blir att erbjuda signering till användarna i form av en html-sida. Från denna html sida görs en Http POST till https://service-host.com/sign/prepare med följande parametrar i dess body:
  * `tbs - Data som skall signeras`
  * `submitUri - Uri till den tjänst som vi satte upp i steg 1`
  * `clientType - Anger vilken typ av nyckel som skall användas vid signeringen. Välj mellan: BankId, Telia, Nordea eller SITHS. Utelämnas detta kommer signeringstjänsten att presentera sida där användaren får välja.`
 # Nu är det dags för ett första försök, går allt bra så kan du fortsätta till nästa steg.
 # Funkar allt nu så är det dags att säkra upp överföringen av signaturen. Detta görs i två steg
  # Aktivera https på den tjänst som aktiverades i steg 1. Hur man gör detta beror på vilken webserver man använder. Vid anslutning mot utbildnings-miljön kan man använda ett egenutfärdat certifikat.
  # Den publika delen av certifikatet måste skickas till en administratör av signeringstjänten för import i dess truststore.
 # Slutligen så skall vi aktivera Mutual Authentication, detta för att den anslutande applikationen skall veta att det är signeringstjänsten som skickar signaturen och inte någon annan som utger sig för att vara det. Detta t.ex. kan ske i en [http://en.wikipedia.org/wiki/Man-in-the-middle_attack man-in-the-middle-attack]. Vi gör även detta i två steg:
  # Aktivera Mutual Authentication på webbservern. Detta är levereantörsspecifikt, på tomcat t.ex. sätts attributet clientAuth på connector-taggen i server.xml till true.
  # Ladda ner och lägg in signeringstjänstens [klient-certifikat] i ditt truststore.